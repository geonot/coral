coral_script = { top_level_statement } , EOF ;

top_level_statement = definition | statement ;

definition = function_definition | object_definition | store_definition | actor_definition | module_definition ;

statement = assignment
          | expression_statement
          | conditional_statement
          | loop_statement
          | use_statement
          | return_statement
          | break_statement
          | continue_statement
          | log_statement
          | empty_statement
          ;

empty_statement = NEWLINE ;
break_statement = 'break' ;
continue_statement = 'continue' ;
log_statement = 'log' , expression ;

assignment = assignable_target , 'is' , ( expression | map_block_assignment_rhs )
            | ( expression | map_block_assignment_rhs ) , 'is' , assignable_target ;

assignable_target = primary_expression_base , { property_access_suffix | list_element_access_suffix } ;

expression_statement = full_expression ;

return_statement = 'return' , [ expression ] ;

full_expression = expression , { error_handler_suffix } ;

error_handler_suffix = 'err' , error_action ;
error_action = ( 'return' , [ expression ] ) | expression | statement_or_block ;    

expression = ternary_conditional_expression ;

ternary_conditional_expression = logical_or_expression , [ '?' , expression , '!' , expression ] ;

logical_or_expression = logical_and_expression , { 'or' , logical_and_expression } ;

logical_and_expression = comparison_expression , { 'and' , comparison_expression } ;

comparison_expression = additive_expression , { ( 'equals' | 'not equals' | 'gt' | 'gte' | 'lt' | 'lte' ) , additive_expression } ;

additive_expression = multiplicative_expression , { ( '+' | '-' ) , multiplicative_expression } ;

multiplicative_expression = unary_expression , { ( '*' | '/' | '%' ) , unary_expression } ;

unary_expression = [ '-' | 'not' ] , value_or_invocation ;

// A primary expression followed by any mix of property accesses, list accesses, calls, or bangs
value_or_invocation = primary_expression_base , { postfix_operation }* ;

postfix_operation = property_access_suffix 
                  | list_element_access_suffix 
                  | call_operation 
                  | across_suffix
                  | postfix_bang_suffix ;

primary_expression_base = IDENTIFIER
                        | literal
                        | parameter_reference
                        | list_literal
                        | map_literal
                        | string_interpolation
                        | '(' , expression , ')'
                        ;

parameter_reference = '$' , [ IDENTIFIER | INTEGER_LITERAL ] ;

property_access_suffix = '.' , IDENTIFIER ;
list_element_access_suffix = '[' , expression , ']' ;
call_operation = '(' , [ argument_list ] , ')' ;
across_suffix = '.' , 'across' , '(' , expression , ')' , [ '.' , 'into' , '(' , IDENTIFIER , ')' ] ;
postfix_bang_suffix = '!' ;

argument_list = argument , { ',' , argument } ;
argument = [ IDENTIFIER , ':' ] , expression ;

literal = STRING_LITERAL | INTEGER_LITERAL | FLOAT_LITERAL | boolean_literal | 'empty' | 'now' ;
boolean_literal = 'true' | 'false' | 'yes' | 'no' ;

list_literal = '(' , [ expression , { ',' , expression } , [ ',' ] ] , ')' ;
map_literal = '(' , [ map_entry , { ',' , map_entry } , [ ',' ] ] , ')' ;
map_entry = IDENTIFIER , ':' , expression ;

string_interpolation = '\'' , { string_part } , '\''
                     | '"' , { string_part } , '"' ;
string_part = STRING_CONTENT | '{' , expression , '}' ;

map_block_assignment_rhs = NEWLINE , INDENT , { map_block_entry } , DEDENT ;
map_block_entry = IDENTIFIER , 'is' , expression , NEWLINE ;

function_definition = 'fn' , IDENTIFIER , function_parameters , function_body ;
function_parameters = '(' , [ parameter_definition , { ',' , parameter_definition } ] , ')' ;
parameter_definition = IDENTIFIER , [ ':' , type_specifier ] , [ '?' , expression ] ;

function_body = ( expression , NEWLINE )
              | ( NEWLINE , INDENT , { statement } , [ [ 'return' ] , expression , NEWLINE ] , DEDENT )
              | ( NEWLINE , INDENT , { statement } , DEDENT )
              ;

object_definition = 'object' , IDENTIFIER , NEWLINE , INDENT , { object_member } , DEDENT ;
object_member = field_definition | method_definition ;
field_definition = IDENTIFIER , [ '?' , expression ] , NEWLINE | IDENTIFIER , NEWLINE ;
method_definition = IDENTIFIER , [ function_parameters ] , function_body 
                  | 'make' , [ function_parameters ] , function_body ;

store_definition = 'store' , [ 'actor' ] , IDENTIFIER , [ 'for' , IDENTIFIER ] , NEWLINE , INDENT , { store_member } , DEDENT ;
store_member = field_definition | method_definition | relation_definition | cast_definition | receive_handler ;
relation_definition = '&' , IDENTIFIER , NEWLINE ;
cast_definition = 'as' , ( 'string' | 'map' | 'list' ) , cast_body ;
cast_body = ( expression , NEWLINE )
          | ( NEWLINE , INDENT , { ( expression | assignment ) , NEWLINE } , DEDENT )
          ;
receive_handler = '@' , IDENTIFIER , function_body ;

actor_definition = 'actor' , IDENTIFIER , NEWLINE , INDENT , { actor_member } , DEDENT ;
actor_member = field_definition | method_definition | receive_handler ;

conditional_statement = if_then_else_statement
                      | unless_statement
                      | postfix_unless_statement
                      ;

if_then_else_statement = 'if' , expression , statement_or_block
                         , { 'else' , 'if' , expression , statement_or_block }
                         , [ 'else' , statement_or_block ]
                         ;
unless_statement = 'unless' , expression , statement_or_block ;
postfix_unless_statement = expression_statement , 'unless' , expression ;

statement_or_block = statement
                   | ( NEWLINE , INDENT , { statement } , DEDENT )
                   ;

loop_statement = while_loop | until_loop | iterate_loop ;

while_loop = 'while' , expression , statement_or_block ;
until_loop = 'until' , expression , statement_or_block ;
iterate_loop = 'iterate' , expression , [ '(' , IDENTIFIER , ')' ] , statement_or_block ;

module_definition = 'mod' , IDENTIFIER , NEWLINE , INDENT , { top_level_statement } , DEDENT ;
use_statement = 'use' , qualified_identifier ;
qualified_identifier = IDENTIFIER , { '.' , IDENTIFIER } ;

type_specifier = primitive_type | list_type | map_type | function_type | user_type ;
primitive_type = 'i8' | 'i16' | 'i32' | 'i64' | 'f32' | 'f64' | 'bool' | 'string' | 'unit' ;
list_type = '(' , type_specifier , ')' ;
map_type = '(' , type_specifier , ':' , type_specifier , ')' ;
function_type = 'fn' , '(' , [ type_specifier , { ',' , type_specifier } ] , ')' , '->' , type_specifier ;
user_type = IDENTIFIER ;

(* Lexical Tokens:
   IDENTIFIER, STRING_LITERAL, INTEGER_LITERAL, FLOAT_LITERAL, STRING_CONTENT,
   NEWLINE, INDENT, DEDENT, EOF,
   Keywords: 'is', 'fn', 'true', 'false', 'yes', 'no', 'if', 'else', 'unless', 'while', 'until', 'iterate', 'return', 'break', 'continue', 'log', 'mod', 'use', 'object', 'store', 'actor', 'empty', 'now', 'or', 'and', 'not', 'equals', 'not equals', 'gt', 'gte', 'lt', 'lte', 'as', 'for', 'err', 'with', 'across', 'into', 'make',
   Symbols: '.', '(', ')', ',', ':', '+', '-', '*', '/', '%', '>', '>=', '<', '<=', '?', '!', '&', '@', '{', '}', '\'', '$'
*)